{"ast":null,"code":"var _defineProperty = require(\"/home/shymoon/Desktop/WebDevProjects/basket-world/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// eslint-disable-next-line node/no-missing-require\nconst {\n  EventEmitter\n} = require('node:events');\nconst WebSocket = require('ws');\nconst RESPONSE_TIMEOUT = 1000 * 30;\nclass Index extends EventEmitter {\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor(_webSocketUrl) {\n    super();\n    _defineProperty(this, \"id\", 0);\n    _defineProperty(this, \"connected\", false);\n    _defineProperty(this, \"events\", []);\n    _defineProperty(this, \"browsingContexts\", []);\n    this.connected = false;\n    this._ws = new WebSocket(_webSocketUrl);\n    this._ws.on('open', () => {\n      this.connected = true;\n    });\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection() {\n    return new Promise(resolve => {\n      if (this.connected) {\n        resolve();\n      } else {\n        this._ws.once('open', () => {\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket() {\n    return this._ws;\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected() {\n    return this.connected;\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send(params) {\n    if (!this.connected) {\n      await this.waitForConnection();\n    }\n    const id = ++this.id;\n    this._ws.send(JSON.stringify({\n      id,\n      ...params\n    }));\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`));\n        handler.off('message', listener);\n      }, RESPONSE_TIMEOUT);\n      const listener = data => {\n        try {\n          const payload = JSON.parse(data.toString());\n          if (payload.id === id) {\n            clearTimeout(timeoutId);\n            handler.off('message', listener);\n            resolve(payload);\n          }\n        } catch (err) {\n          // eslint-disable-next-line no-undef\n          log.error(`Failed parse message: ${err.message}`);\n        }\n      };\n      const handler = this._ws.on('message', listener);\n    });\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe(events, browsingContexts) {\n    function toArray(arg) {\n      if (arg === undefined) {\n        return [];\n      }\n      return Array.isArray(arg) ? [...arg] : [arg];\n    }\n    const eventsArray = toArray(events);\n    const contextsArray = toArray(browsingContexts);\n    const params = {\n      method: 'session.subscribe',\n      params: {}\n    };\n    if (eventsArray.length && eventsArray.some(event => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array');\n    }\n    if (contextsArray.length && contextsArray.some(context => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array');\n    }\n    if (eventsArray.length) {\n      params.params.events = eventsArray;\n    }\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe(events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter(event => event !== events);\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter(event => !events.includes(event));\n    }\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop();\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts = this.browsingContexts.filter(id => !browsingContexts.includes(id));\n    }\n    const params = {\n      method: 'session.unsubscribe',\n      params: {\n        events: this.events\n      }\n    };\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status() {\n    return this.send({\n      method: 'session.status',\n      params: {}\n    });\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close() {\n    const closeWebSocket = callback => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback();\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close');\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners();\n          callback();\n        });\n        this._ws.close();\n      }\n    };\n    return new Promise((fulfill, _) => {\n      closeWebSocket(fulfill);\n    });\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index;","map":{"version":3,"names":["EventEmitter","require","WebSocket","RESPONSE_TIMEOUT","Index","constructor","_webSocketUrl","_defineProperty","connected","_ws","on","waitForConnection","Promise","resolve","once","socket","isConnected","send","params","id","JSON","stringify","reject","timeoutId","setTimeout","Error","handler","off","listener","data","payload","parse","toString","clearTimeout","err","log","error","message","subscribe","events","browsingContexts","toArray","arg","undefined","Array","isArray","eventsArray","contextsArray","method","length","some","event","TypeError","context","contexts","unsubscribe","filter","includes","pop","status","close","closeWebSocket","callback","readyState","removeAllListeners","fulfill","_","module","exports"],"sources":["/home/shymoon/Desktop/WebDevProjects/basket-world/node_modules/selenium-webdriver/bidi/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// eslint-disable-next-line node/no-missing-require\nconst { EventEmitter } = require('node:events')\nconst WebSocket = require('ws')\n\nconst RESPONSE_TIMEOUT = 1000 * 30\n\nclass Index extends EventEmitter {\n  id = 0\n  connected = false\n  events = []\n  browsingContexts = []\n\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor(_webSocketUrl) {\n    super()\n    this.connected = false\n    this._ws = new WebSocket(_webSocketUrl)\n    this._ws.on('open', () => {\n      this.connected = true\n    })\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection() {\n    return new Promise((resolve) => {\n      if (this.connected) {\n        resolve()\n      } else {\n        this._ws.once('open', () => {\n          resolve()\n        })\n      }\n    })\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket() {\n    return this._ws\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected() {\n    return this.connected\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send(params) {\n    if (!this.connected) {\n      await this.waitForConnection()\n    }\n\n    const id = ++this.id\n\n    this._ws.send(JSON.stringify({ id, ...params }))\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`))\n        handler.off('message', listener)\n      }, RESPONSE_TIMEOUT)\n\n      const listener = (data) => {\n        try {\n          const payload = JSON.parse(data.toString())\n          if (payload.id === id) {\n            clearTimeout(timeoutId)\n            handler.off('message', listener)\n            resolve(payload)\n          }\n        } catch (err) {\n          // eslint-disable-next-line no-undef\n          log.error(`Failed parse message: ${err.message}`)\n        }\n      }\n\n      const handler = this._ws.on('message', listener)\n    })\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe(events, browsingContexts) {\n    function toArray(arg) {\n      if (arg === undefined) {\n        return []\n      }\n\n      return Array.isArray(arg) ? [...arg] : [arg]\n    }\n\n    const eventsArray = toArray(events)\n    const contextsArray = toArray(browsingContexts)\n\n    const params = {\n      method: 'session.subscribe',\n      params: {},\n    }\n\n    if (eventsArray.length && eventsArray.some((event) => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array')\n    }\n\n    if (contextsArray.length && contextsArray.some((context) => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array')\n    }\n\n    if (eventsArray.length) {\n      params.params.events = eventsArray\n    }\n\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe(events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter((event) => event !== events)\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter((event) => !events.includes(event))\n    }\n\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop()\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts = this.browsingContexts.filter((id) => !browsingContexts.includes(id))\n    }\n\n    const params = {\n      method: 'session.unsubscribe',\n      params: {\n        events: this.events,\n      },\n    }\n\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status() {\n    return this.send({\n      method: 'session.status',\n      params: {},\n    })\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close() {\n    const closeWebSocket = (callback) => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback()\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close')\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners()\n          callback()\n        })\n        this._ws.close()\n      }\n    }\n    return new Promise((fulfill, _) => {\n      closeWebSocket(fulfill)\n    })\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}